/*
 * ======== Standard MSP430 includes ========
 */
#include <msp430.h>

/*
 * ======== Grace related includes ========
 */
#include <ti/mcu/msp430/Grace.h>




int findaverage(int outavg[150], unsigned int H);
/*
 *  ======== main ========
 */
int main(void)
{
    Grace_init();   // Activate Grace-generated configuration



    
    	unsigned int B,D =0;
		int outarr[150];
		//int avgarr [10];

  		int filtered=0;
  		int peak10 = 0;


  		unsigned int k;
  		int audio=0;
  		int CenterTap=0;

  		int RegX1[4],RegX2[4],RegY1[4],RegY2[4];

  		const float a1[]={-1.169925255,-1.402167657,-1.120723799,-1.649948614};
  		const float a2[]={0.6360640657,0.6962444294,0.8186383078,0.8846651141};
  		const float b0[]={-0.173675154,-0.1901072,-0.1910775392,-0.2064887892};
  		const float b2[]={0.173675154,0.1901072,0.1910775392,0.2064887892};



  				for (k=0; k>3; ++k)
  				{
  					RegX1[k]=0;
  					RegX2[k]=0;				//Clear the registers
  					RegY1[k]=0;
  					RegY2[k]=0;

  				}







  				while(1)

	{









  		if (P2OUT && BIT4 == BIT4)




  		{



			P1OUT |=BIT6;


  			ADC10CTL0 |= ENC + ADC10SC;



  						 /* Loop until ADC10IFG is set indicating ADC conversion complete */
  						 while ((ADC10CTL0 & ADC10IFG) == 0);


  						 audio = ADC10MEM;

  						 for(k=0; k<3; k++) /* 4 + 0 is the number of sections - stop when 4 is reached*/
  						 {



  						 CenterTap = ((audio * b0[k]) + (b2[k] * RegX2[k]));
  						 filtered = (CenterTap - (a1[k] * RegY1[k]) - (a2[k] * RegY2[k]));

  						 	   RegX2[k] = RegX1[k];
  						 	   RegX1[k] = audio;
  						 	   RegY2[k] = RegY1[k];
  						 	   RegY1[k] = filtered;
  						 	   audio = filtered;


  						 }


  						P2OUT &= ~BIT4;

  						outarr[B]=filtered; //get 150 samples of filter

  						++B;


  						P1OUT &= ~BIT6;
  		}



  					/* USER CODE END (section: TIMER0_A0_ISR_HOOK) */






			if (B > 149)





			{

				TA0CTL &= ~BIT4;
			  	peak10 = findaverage(outarr,149)*2;
			  	//++D;
			  	//avgarr[D]




			//	if (D>10)
			//	{

			//	peak10 = findaverage(avgarr, 9);
			//	peak10 *= (peak10/10);

			//	D=0;
			//	}
				B=0;

				}





			if (filtered > peak10)

				 {


 					P1OUT |= BIT0;
					TA1CTL |= BIT4;


					}







  	}





}


	int findaverage(int outavg[], unsigned int H)


		{


		unsigned int X=0;
		int peak= 0;
		unsigned int D = 0;
		unsigned int M = 0;
		int peakavg = 0;




			for (X= 0; X < H; )


		  			{

				peak = 0;
				for (M=0;M<6;++M)

		  	    	  {



						if (outavg[X] > 0)
						{
		  	    		 if (outavg[X]> peak)
		  	    		 {
		  	    		  peak = outavg[X];



		  	    		 }
		  	    		 }
						 ++X;
		  	    	  }



			 	 	 peakavg += peak;

			 	 	 ++D;

		  			}





		  		peakavg /= D;



		  	  if (peakavg < 15)

		  	  {
		  	  	peakavg = 15;
		  	  }

		  	TA0CTL |= BIT4;
		  	return (peakavg);
}
/*
 *  This file is automatically generated and does not require a license
 *
 *  ==== WARNING: CHANGES TO THIS GENERATED FILE WILL BE OVERWRITTEN ====
 *
 *  To make changes to the generated code, use the space between existing
 *      "USER CODE START (section: <name>)"
 *  and
 *      "USER CODE END (section: <name>)"
 *  comments, where <name> is a single word identifying the section.
 *  Only these sections will be preserved.
 *
 *  Do not move these sections within this file or change the START and
 *  END comments in any way.
 *  ==== ALL OTHER CHANGES WILL BE OVERWRITTEN WHEN IT IS REGENERATED ====
 *
 *  This file was generated from
 *      C:/ti/grace_3_10_00_82/packages/ti/mcu/msp430/csl/interrupt_vectors/InterruptVectors_init.xdt
 */
#include <msp430.h>
#include "_Grace.h"

/* USER CODE START (section: InterruptVectors_init_c_prologue) */


/* USER CODE END (section: InterruptVectors_init_c_prologue) */

/*
 *  ======== InterruptVectors_graceInit ========
 */
void InterruptVectors_graceInit(void)
{
}


/* Interrupt Function Prototypes */




/*
 *  ======== Timer0_A3 Interrupt Service Routine ======== 
 */
#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR_HOOK(void)
{
    /* USER CODE START (section: TIMER0_A0_ISR_HOOK) */
  P2OUT |=BIT4;

    /* USER CODE END (section: TIMER0_A0_ISR_HOOK) */
}

/*
 *  ======== Timer0_A3 Interrupt Service Routine ======== 
 */
#pragma vector=TIMER0_A1_VECTOR
__interrupt void TIMER0_A1_ISR_HOOK(void)
{
    /* USER CODE START (section: TIMER0_A1_ISR_HOOK) */
    /* replace this comment with your code */
    /* USER CODE END (section: TIMER0_A1_ISR_HOOK) */
}

/*
 *  ======== Timer1_A3 Interrupt Service Routine ======== 
 */
#pragma vector=TIMER1_A0_VECTOR
__interrupt void TIMER1_A0_ISR_HOOK(void)
{
    /* USER CODE START (section: TIMER1_A0_ISR_HOOK) */



	P1OUT &= ~BIT0;
	TA1CTL &=~BIT4;


	/* USER CODE END (section: TIMER1_A0_ISR_HOOK) */
}

